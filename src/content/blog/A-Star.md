---
author: cobo
pubDatetime: 2023-01-30T15:57:52.737Z
title: A-Star
featured: false
draft: false
tags:
 - robot
description: this is auto generate
---
 #静态网络 #最小路径 #启发式算法

>A-Star算法，A*(A-Star)算法是一种静态路网中求解[最短路径](https://baike.baidu.com/item/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/6334920?fromModule=lemma_inlink)最有效的**直接**搜索方法，也是解决许多搜索问题的有效算法。算法中的距离估算值与实际值越接近，最终[搜索](https://baike.baidu.com/item/%E6%90%9C%E7%B4%A2/1806?fromModule=lemma_inlink)速度越快。

A* （A-Star)算法是一种静态路网中求解最短路径最有效的直接[搜索](https://baike.baidu.com/item/%E6%90%9C%E7%B4%A2/5395421?fromModule=lemma_inlink)方法，也是许多其他[问题](https://baike.baidu.com/item/%E9%97%AE%E9%A2%98/13018756?fromModule=lemma_inlink)的常用启发式算法。注意——是最有效的**直接**搜索算法，之后涌现了很多预处理算法（如CH），在线查询效率是A*算法的数千甚至上万倍。

**距离估计与实际值越接近，估价函数取得就越好**

例如对于几何路网来说，可以取两节点间[[曼哈顿距离]]做为距离估计，即f=g(n) + (abs(dx - nx) + abs(dy - ny))；这样估价函数f(n)在g(n)一定的情况下，会或多或少的受距离估计值h(n)的制约，节点距目标点近，h值小，f值相对就小，能保证最短路的搜索向终点的方向进行。明显优于[[Dijkstra]]算法的毫无方向的向四周搜索。

**公式表示：F(n)=G(n)+H(n)**
其中F(n)是每个可能试探点的估值，它有两部分组成：
一部分，为G(n)，它表示从起始搜索点到当前点的代价（通常用某结点在搜索树中的深度来表示）。
另一部分，即H(n)，它表示启发式搜索中最为重要的一部分，即当前结点到目标结点的估值，
H(n)设计的好坏，直接影响着具有此种启发式函数的启发式算法的是否能称为A*算法。
一种具有F(n)=G(n)+H(n)策略的启发式算法能成为A*算法的充分条件是：  
1. 搜索树上存在着从起始点到终了点的最优路径。  
2. 问题域是有限的。  
3. 所有结点的子结点的搜索代价值>0。  
4. H(n)=<H*(n) （h*(n)为实际问题的代价值
当此四个条件都满足时，一个具有F(n)=G(n)+H(n)策略的启发式算法能成为A*算法，并一定能找到最优解

## 游戏类比
寻路的第一步是简化成容易控制的搜索区域。

怎么处理要根据游戏来决定了。例如，我们可以将搜索区域划分成像素点，但是这样的划分粒度对于我们这款基于方块的游戏来说太高了（没必要）。

作为代替，我们使用方块（一个正方形）作为寻路算法的单元。其他的形状类型也是可能的（比如三角形或者六边形），但是正方形是最简单并且最适合我们需求的。

像那样去划分，我们的搜索区域可以简单的用一个地图大小的二维数组去表示。所以如果是25*25方块大小的地图，我们的搜索区域将会是一个有625 个正方形的数组。如果我们把地图划分成像素点，搜索区域就是一个有640，000个正方形的数组了（一个方块是32*32像素）！

现在让我们基于目前的区域，把区域划分成多个方块来代表搜索空间：

**Open和Close列表**

1. 一个记录下所有被考虑来寻找最短路径的点的集合（称为Open列表）
2. 一个记录下不会被考虑为最短路径的点的集合（称为Closed列表）
**路径增量**
我们将会给每个方块一个G+H 和值：

-   G是从开始点A到当前方块的移动量。所以从开始点A到相邻小方块的移动量为1，该值会随着离开始点越来越远而增大。
-   H是从当前方块到目标点（我们把它称为点B）的移动量估算值。这个常被称为探视，因为我们不确定移动量是多少 – 仅仅是一个估算值。移动量估算值离真实值越接近，最终的路径会更加精确。如果估算值停止作用，很可能生成出来的路径不会是最短的（但是它可能是接近的）。这个题目相对复杂，所以我们不会再本教程中讲解，但是我在教程的末尾提供了一个网络链接，对它做了很好的解释。

为了让它更简单，我们将使用“曼哈顿距离方法”（也叫“曼哈顿长”或者“城市街区距离”），它只是计算出距离点B，剩下的水平和垂直的方块数量，略去了障碍物或者不同陆地类型的数量。两节点间曼哈顿距离做为距离估计，即F(n)=G(n) + (abs(dx - nx) + abs(dy - ny))。

你也许会对“移动量”感兴趣。在游戏中，这个概念很简单 – 仅仅是方块的数量。

然而，在游戏中你可以对这个值做调整。例如：

-   如果你允许对角线移动，你可以针对对角线移动把移动量调得大一点。
-   如果你有不同的地形，你可以将相应的移动量调整得大一点 – 例如针对一块沼泽，水，或者猫女海报:-)

## A-Star算法
既然你知道如何计算每个方块的和值（我们将它称为F，等于G+H), 我们来看下A星算法的原理。

猫会重复以下步骤来找到最短路径：

1.  将方块添加到open列表中，该列表有最小的和值。且将这个方块称为S吧。
2.  将S从open列表移除，然后添加S到closed列表中。
3.  对于与S相邻的每一块可通行的方块T：
	1.  如果T在closed列表中：不管它。
	2.  如果T不在open列表中：添加它然后计算出它的和值。
	3.  如果T已经在open列表中：当我们使用当前生成的路径到达那里时，检查F 和值是否更小。如果是，更新它的和值和它的前继。