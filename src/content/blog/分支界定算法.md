---
author: cobo
pubDatetime: 2023-01-30T15:57:52.737Z
title: 分支界定算法
featured: false
draft: false
tags:
 - robot
description: this is auto generate
---
#整数规划
>分支定界法（branch and bound）是一种求解[整数规划](https://baike.baidu.com/item/%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/2452450?fromModule=lemma_inlink)问题的最常用算法。这种方法不但可以求解纯整数规划，还可以求解[混合整数规划](https://baike.baidu.com/item/%E6%B7%B7%E5%90%88%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/19132391?fromModule=lemma_inlink)问题。分支定界法是一种搜索与迭代的方法，选择不同的分支变量和子问题进行分支

通常，把全部可行解空间反复地分割为越来越小的子集，称为分支；并且对每个子集内的解集计算一个目标下界（对于最小值问题），这称为定界。在每次分枝后，凡是界限超出已知可行解集目标值的那些子集不再进一步分枝，这样，许多子集可不予考虑，这称剪枝。这就是分枝定界法的主要思路

>分枝界限法是由三栖学者理查德·卡普（Richard M.Karp）在20世纪60年代发明，成功求解含有65个城市的旅行商问题，创当时的记录。“分枝界限法”把问题的可行解展开如树的分枝，再经由各个分枝中寻找最佳解。

分枝界限法也能够使用在混合整数规划问题上，其为一种系统化的解法，以一般线性规划之单形法解得最佳解后，将非整数值之决策变量分割成为最接近的两个整数，分列条件，加入原问题中，形成两个子问题(或分枝)分别求解，如此便可求得目标函数值的上限（上界）或下限（下界），从其中寻得最佳解

分支定界法求背包问题：

 问题：一个容量为10的集装箱，有重量分别为4,8,5的货物，如何才能装最多：
![分支定界png](分支定界.png)
FIFO算法：

1. 首先定义best=0
2. 第一层，4被选择，此时的best修改成4，加入到队列中；0<best 计算0节点的最大期望，13>best，加入到队列中。
3. 第二层，8被选择，12>10，截枝；4=best，加入到队列中；8>best, 加入到队列，修改best=8，0节点的最大期望小<best，截枝；
4. 第三层，修改best即可。

?最大期望如何求得

> 选择完，找到最大期望，感觉做了个搜索树，不满足条件提前弹出，其他存入期望队列，继续搜索，求值

```python
import numpy as np

capacity = 10  # 背包的容量是10
goods = [4, 8, 5]  # 货物重量
best = 0  # 最优重量
expect = sum(goods)  # 期望值

queue = [0]  # 记录每层的节点
layer = 0  # 记录层数

while layer < np.size(goods)-1:
    # 取出该层的所有节点，作为下层的父节点
    expect = expect - goods[layer]  # 修改期望值
    parents = np.array(queue)
    nowParents = parents + goods[layer]
    temp_best = np.max(np.where(nowParents > capacity, 0, nowParents))

    # 更新best
    if best < temp_best:
        best = temp_best

    # 选择候选集， 截枝操作
    nowParents = np.hstack((nowParents, parents))
    temp_queue = []
    for i in nowParents:
        if i + expect > best:
            temp_queue.append(i)
    queue = temp_queue

    layer = layer + 1

# 最后一层，计算最优值
parents = np.array(queue)
nowParents = parents + goods[layer]

nowParents = np.hstack((nowParents, parents))
best = np.max(np.where(nowParents > capacity, 0, nowParents))

print(best)
```

