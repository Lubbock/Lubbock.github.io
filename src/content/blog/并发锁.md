---
author: cobo
pubDatetime: 2023-01-30T15:57:52.737Z
title: 并发锁
featured: false
draft: false
tags:
 - robot
description: this is auto generate
---

锁的正确理解，是必须结合操作系统原理才能明了的。

相关书籍/课程为了说清楚自身核心内容，是必需做一些内容上的切割的。非如此不足以把基本概念讲清楚。

但是，作为学习者，是必须在完全理解分离的基本概念的基础上，在脑中重新组合它们、从而形成正确、系统的全景图像的。非如此，则理论无法指导实践。

所以，我先粗略介绍下操作系统的“进程调度”。
进程是什么、进程调度是什么，这里就不再重复了。
这里面需要注意的知识点是：进程调度会把“缺乏资源”的进程置于[休眠队列](https://www.zhihu.com/search?q=%E4%BC%91%E7%9C%A0%E9%98%9F%E5%88%97&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A246760992%7D)、又要把休眠队列中资源要求可以满足的进程置于等待队列——然后时间片一到就会调度运行。

一般学到这里，我们都会觉得“资源”嘛，就是磁盘访问、[网络通信](https://www.zhihu.com/search?q=%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A246760992%7D)之类东西：它们忙不忙，操作系统自然是知道的……
其实不然。
操作系统在这里做了“归一化”处理，它压根懒得知道你在等什么（不然进程调度就实现的过于复杂了）。所谓的“资源”，在进程调度逻辑看来，就是一个个“锁”——[请求锁](https://www.zhihu.com/search?q=%E8%AF%B7%E6%B1%82%E9%94%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A246760992%7D)得不到满足，就是“缺乏资源”；锁被释放了，请求它的进程显然就有“资源”可用了。。

（那么，我们可以用一些分析工具看出，多少进程阻塞在磁盘访问上了，这个是从何而来的呢？答案是，操作系统会维护一个“锁”的列表；找到这个锁的对应项，读它的相关信息，再找到申请它的[进程队列](https://www.zhihu.com/search?q=%E8%BF%9B%E7%A8%8B%E9%98%9F%E5%88%97&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A246760992%7D)，自然就知道哪些进程试图访问磁盘、但暂时得不到满足了——注意这类锁并不需要进程显式申请，相关逻辑已经包含在对应的[系统调用](https://www.zhihu.com/search?q=%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A246760992%7D)里了）


有了这个基础，再看锁，就清晰明了了：

1、“自旋锁”是一种“申请不到也不知会操作系统”的锁。

这可以避免进程因被识别为“资源不足”而被操作系统置入休眠队列，从而避免不必要的[上下文切换](https://www.zhihu.com/search?q=%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A246760992%7D)开销；但缺点是，它会导致“申请不到锁时执行死循环”，使得CPU核心占用100%——如果是单核单线程CPU，它就白白发一个时间片的热然后失去执行权（因为它占用了时间片，导致能释放资源给它的进/线程压根得不到执行机会）；只有在多CPU和/或多核和/或多线程硬件平台上、且这个锁一定会在远短于一个时间片的时间内被请求到，它才可能真正提高效率（否则又是白白浪费时间、电力让CPU发热了）。

总之，使用[自旋锁](https://www.zhihu.com/search?q=%E8%87%AA%E6%97%8B%E9%94%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A246760992%7D)必须非常慎重，须先模拟各种不同场景做好profile、然后根据数据决定是否使用它。

2、其它锁都是“申请不到就通知操作系统：资源不足，我没法干活了，申请休息”。

于是操作系统暂停当前进程（线程）并将其置于[等待/休眠队列](https://www.zhihu.com/search?q=%E7%AD%89%E5%BE%85%2F%E4%BC%91%E7%9C%A0%E9%98%9F%E5%88%97&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A246760992%7D)，腾出它的CPU给其它进/线程使用；直到另外一个进程（线程）释放锁、它才可以再次得到执行机会。

  

  

进一步的，资源又分许多种：

有的资源同时只允许一个访问，无论读写；于是我们抽象它为“[互斥锁](https://www.zhihu.com/search?q=%E4%BA%92%E6%96%A5%E9%94%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A246760992%7D)”。

有的资源同时只允许一个修改、但可以允许许多个读取（读取时不得写入）；于是我们抽象它为“[读写锁](https://www.zhihu.com/search?q=%E8%AF%BB%E5%86%99%E9%94%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A246760992%7D)”。

此外，还有一类典型的资源访问场景，是“甲做某些先期准备、就绪后再由乙接续工作”（比如“甲从网络上接受报文并拆包以取出任务，一组工作者乙等待处理已经拆包的任务”）——如果用[普通锁](https://www.zhihu.com/search?q=%E6%99%AE%E9%80%9A%E9%94%81&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A246760992%7D)在用户态写，要么会搞的很复杂，要么就得忙等（不停的扫描检查条件是否满足）；使用条件变量，就可以让甲每取出一个任务就发一个通知，然后操作系统自动转发通知给乙（所谓“转发通知”，实质上是，平常乙执行“等待条件变量”系统调用、然后因条件得不到满足而被操作系统自动挂起；等条件满足了，操作系统才会让其继续执行）。

  

你看，通过不同的锁，进程就可以配合操作系统，做到“既不浪费CPU时间、又尽量把各种资源利用到极致”了。

