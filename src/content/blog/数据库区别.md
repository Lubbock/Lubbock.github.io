---
author: cobo
pubDatetime: 2023-01-30T15:57:52.737Z
title: 数据库区别
featured: false
draft: false
tags:
 - robot
description: this is auto generate
---
# 数据库差异
## date_format
#### mysql
在MySQL数据库中，DATE_FORMAT函数用于将日期类型的数据按照指定的格式进行格式化，以便更好地呈现给用户或应用程序。

语法：

```sql
DATE_FORMAT(date, format)
```

其中，date是日期类型的数据，可以是一个具体的日期值或日期列，format是要将日期格式化的字符串。

常用的format格式选项：

- `%Y`: 四位数的年份（例如：2023）
- `%y`: 两位数的年份（例如：23）
- `%m`: 两位数的月份（01-12）
- `%d`: 两位数的日期（01-31）
- `%H`: 24小时制的小时（00-23）
- `%h`: 12小时制的小时（01-12）
- `%i`: 两位数的分钟（00-59）
- `%s`: 两位数的秒数（00-59）
- `%W`: 完整的星期几名称（例如：Monday）
- `%w`: 数字表示的星期几（0表示星期日，1表示星期一，以此类推）

示例：

假设有一个名为"orders"的表，其中有一个名为"order_date"的日期列，存储了订单日期。

1. 将日期格式化为"YYYY-MM-DD"的格式：

```sql
SELECT DATE_FORMAT(order_date, '%Y-%m-%d') AS formatted_date FROM orders;
```

2. 将日期格式化为"YYYY年MM月DD日"的格式：

```sql
SELECT DATE_FORMAT(order_date, '%Y年%m月%d日') AS formatted_date FROM orders;
```

3. 将日期格式化为"HH:MM:SS"的格式：

```sql
SELECT DATE_FORMAT(order_date, '%H:%i:%s') AS formatted_time FROM orders;
```

通过使用DATE_FORMAT函数，您可以根据实际需求将日期数据以特定的格式进行展示或处理。

### DM
在DM（达梦数据库）中，与MySQL的DATE_FORMAT函数类似，DM数据库也有一个类似的函数用于将日期类型的数据格式化，该函数称为TO_CHAR函数。

语法：

```sql
TO_CHAR(date_expression, format)
```

其中，date_expression是日期类型的数据，可以是一个具体的日期值或日期列，format是要将日期格式化的字符串，其格式选项与Oracle数据库的日期格式相同。

常用的format格式选项（与Oracle数据库的日期格式一致）：

- `YYYY`: 四位数的年份（例如：2023）
- `YY`: 两位数的年份（例如：23）
- `MM`: 两位数的月份（01-12）
- `DD`: 两位数的日期（01-31）
- `HH24`: 24小时制的小时（00-23）
- `HH12`: 12小时制的小时（01-12）
- `MI`: 两位数的分钟（00-59）
- `SS`: 两位数的秒数（00-59）
- `DAY`: 完整的星期几名称（例如：MONDAY）
- `DY`: 缩写的星期几名称（例如：MON）

示例：

假设有一个名为"orders"的表，其中有一个名为"order_date"的日期列，存储了订单日期。

1. 将日期格式化为"YYYY-MM-DD"的格式：

```sql
SELECT TO_CHAR(order_date, 'YYYY-MM-DD') AS formatted_date FROM orders;
```

2. 将日期格式化为"YYYY年MM月DD日"的格式：

```sql
SELECT TO_CHAR(order_date, 'YYYY"年"MM"月"DD"日"') AS formatted_date FROM orders;
```

3. 将日期格式化为"HH24:MI:SS"的格式：

```sql
SELECT TO_CHAR(order_date, 'HH24:MI:SS') AS formatted_time FROM orders;
```

通过使用TO_CHAR函数，您可以根据实际需求将日期数据以特定的格式进行展示或处理，这在查询结果中非常有用。

### Vastbase
Vastbase是一种关系型数据库，类似于Oracle数据库。在Vastbase数据库中，日期格式化的函数也类似于Oracle数据库，称为TO_CHAR函数。

语法：

```sql
TO_CHAR(date_expression, format)
```

其中，date_expression是日期类型的数据，可以是一个具体的日期值或日期列，format是要将日期格式化的字符串。

常用的format格式选项（与Oracle数据库的日期格式一致）：

- `YYYY`: 四位数的年份（例如：2023）
- `YY`: 两位数的年份（例如：23）
- `MM`: 两位数的月份（01-12）
- `DD`: 两位数的日期（01-31）
- `HH24`: 24小时制的小时（00-23）
- `HH12`: 12小时制的小时（01-12）
- `MI`: 两位数的分钟（00-59）
- `SS`: 两位数的秒数（00-59）
- `DAY`: 完整的星期几名称（例如：MONDAY）
- `DY`: 缩写的星期几名称（例如：MON）

示例：

假设有一个名为"orders"的表，其中有一个名为"order_date"的日期列，存储了订单日期。

1. 将日期格式化为"YYYY-MM-DD"的格式：

```sql
SELECT TO_CHAR(order_date, 'YYYY-MM-DD') AS formatted_date FROM orders;
```

2. 将日期格式化为"YYYY年MM月DD日"的格式：

```sql
SELECT TO_CHAR(order_date, 'YYYY"年"MM"月"DD"日"') AS formatted_date FROM orders;
```

3. 将日期格式化为"HH24:MI:SS"的格式：

```sql
SELECT TO_CHAR(order_date, 'HH24:MI:SS') AS formatted_time FROM orders;
```

通过使用TO_CHAR函数，您可以根据实际需求将日期数据以特定的格式进行展示或处理，这在查询结果中非常有用。请注意，Kingbase数据库的日期格式化与Oracle数据库的日期格式化几乎相同，这使得在这两种数据库之间进行迁移或转换时更加方便。

### Kingbase
Kingbase是一种关系型数据库，类似于Oracle数据库。在Kingbase数据库中，日期格式化的函数也类似于Oracle数据库，称为TO_CHAR函数。

语法：

```sql
TO_CHAR(date_expression, format)
```

其中，date_expression是日期类型的数据，可以是一个具体的日期值或日期列，format是要将日期格式化的字符串。

常用的format格式选项（与Oracle数据库的日期格式一致）：

- `YYYY`: 四位数的年份（例如：2023）
- `YY`: 两位数的年份（例如：23）
- `MM`: 两位数的月份（01-12）
- `DD`: 两位数的日期（01-31）
- `HH24`: 24小时制的小时（00-23）
- `HH12`: 12小时制的小时（01-12）
- `MI`: 两位数的分钟（00-59）
- `SS`: 两位数的秒数（00-59）
- `DAY`: 完整的星期几名称（例如：MONDAY）
- `DY`: 缩写的星期几名称（例如：MON）

示例：

假设有一个名为"orders"的表，其中有一个名为"order_date"的日期列，存储了订单日期。

1. 将日期格式化为"YYYY-MM-DD"的格式：

```sql
SELECT TO_CHAR(order_date, 'YYYY-MM-DD') AS formatted_date FROM orders;
```

2. 将日期格式化为"YYYY年MM月DD日"的格式：

```sql
SELECT TO_CHAR(order_date, 'YYYY"年"MM"月"DD"日"') AS formatted_date FROM orders;
```

3. 将日期格式化为"HH24:MI:SS"的格式：

```sql
SELECT TO_CHAR(order_date, 'HH24:MI:SS') AS formatted_time FROM orders;
```

通过使用TO_CHAR函数，您可以根据实际需求将日期数据以特定的格式进行展示或处理，这在查询结果中非常有用。请注意，Kingbase数据库的日期格式化与Oracle数据库的日期格式化几乎相同，这使得在这两种数据库之间进行迁移或转换时更加方便。

## AVG
### mysql
在MySQL数据库中，AVG函数用于计算数值列的平均值。它返回指定列中所有数值的平均值。

语法：

```sql
AVG(column_name)
```

其中，column_name是要计算平均值的数值列的名称。

示例：

假设有一个名为"sales"的表，其中有一个名为"amount"的列，存储了销售金额。

1. 计算"amount"列的平均值：

```sql
SELECT AVG(amount) AS average_amount FROM sales;
```

通过上述查询，将返回"amount"列中所有数值的平均值，并且使用别名"average_amount"来表示该值。

AVG函数对于统计数值数据的平均值非常有用，并且常常与其他聚合函数（如SUM、COUNT等）结合使用，以实现更复杂的数据分析和汇总。

### DM
在DM（达梦数据库）中，AVG函数用于计算数值列的平均值，与其他主流数据库的AVG函数用法类似。

语法：

```sql
AVG(column_name)
```

其中，column_name是要计算平均值的数值列的名称。

示例：

假设有一个名为"sales"的表，其中有一个名为"amount"的列，存储了销售金额。

1. 计算"amount"列的平均值：

```sql
SELECT AVG(amount) AS average_amount FROM sales;
```

通过上述查询，将返回"amount"列中所有数值的平均值，并使用别名"average_amount"表示该值。

需要注意的是，在不同的数据库管理系统中，函数的语法可能有所不同。如果您在使用不同的数据库时遇到问题，请参考相应数据库的官方文档或查询语法参考。
### kingbase
在Kingbase数据库中，AVG函数用于计算数值列的平均值，与其他主流数据库的AVG函数用法类似。

语法：

```sql
AVG(column_name::numberics)
```

其中，column_name是要计算平均值的数值列的名称。

示例：

假设有一个名为"sales"的表，其中有一个名为"amount"的列，存储了销售金额。

1. 计算"amount"列的平均值：

```sql
SELECT AVG(amount::numberics) AS average_amount FROM sales;
```

通过上述查询，将返回"amount"列中所有数值的平均值，并使用别名"average_amount"表示该值。

需要注意的是，在不同的数据库管理系统中，函数的语法可能有所不同。如果您在使用不同的数据库时遇到问题，请参考相应数据库的官方文档或查询语法参考。

### vastbase
在Kingbase数据库中，AVG函数用于计算数值列的平均值，与其他主流数据库的AVG函数用法类似。

语法：

```sql
AVG(column_name)
```

其中，column_name是要计算平均值的数值列的名称。

示例：

假设有一个名为"sales"的表，其中有一个名为"amount"的列，存储了销售金额。

1. 计算"amount"列的平均值：

```sql
SELECT AVG(amount) AS average_amount FROM sales;
```

通过上述查询，将返回"amount"列中所有数值的平均值，并使用别名"average_amount"表示该值。

需要注意的是，在不同的数据库管理系统中，函数的语法可能有所不同。如果您在使用不同的数据库时遇到问题，请参考相应数据库的官方文档或查询语法参考。

## group by
### mysql
在MySQL数据库中，GROUP BY语句用于对查询结果进行分组，通常结合聚合函数（如SUM、COUNT、AVG等）使用，以便对每个组进行聚合操作。

语法：

```sql
SELECT column1, column2, ..., aggregate_function(column_name)
FROM table_name
GROUP BY column1, column2, ...;
```

其中，column1、column2等是您希望按其进行分组的列，aggregate_function是聚合函数，column_name是要进行聚合操作的列名。

示例：

假设有一个名为"orders"的表，其中包含以下列：order_id、customer_id、order_date和order_amount。

1. 计算每个顾客的订单总金额：

```sql
SELECT customer_id, SUM(order_amount) AS total_amount
FROM orders
GROUP BY customer_id;
```

2. 计算每个月的订单总金额：

```sql
SELECT DATE_FORMAT(order_date, '%Y-%m') AS month, SUM(order_amount) AS total_amount
FROM orders
GROUP BY DATE_FORMAT(order_date, '%Y-%m');
```

在上述示例中，第一个查询根据customer_id对订单进行分组，并使用SUM函数计算每个顾客的订单总金额。第二个查询根据order_date的年份和月份（使用DATE_FORMAT函数）对订单进行分组，并使用SUM函数计算每个月的订单总金额。

GROUP BY语句对于在查询中进行数据分组和聚合操作非常有用。请注意，在使用GROUP BY语句时，SELECT子句中的列必须要么是GROUP BY子句中的列，要么是聚合函数的结果列。

### kingbase
在Kingbase数据库中，GROUP BY语句也用于对查询结果进行分组，以实现数据的分组和聚合操作。GROUP BY语句与MySQL中的语法非常相似。

语法：

```sql
SELECT column1, column2, ..., aggregate_function(column_name)
FROM table_name
GROUP BY column1, column2, ...;
```

其中，column1、column2等是您希望按其进行分组的列，aggregate_function是聚合函数，column_name是要进行聚合操作的列名。

示例：

假设有一个名为"orders"的表，其中包含以下列：order_id、customer_id、order_date和order_amount。

1. 计算每个顾客的订单总金额：

```sql
SELECT customer_id, SUM(order_amount) AS total_amount
FROM orders
GROUP BY customer_id;
```

2. 计算每个月的订单总金额：

```sql
SELECT TO_CHAR(order_date, 'YYYY-MM') AS month, SUM(order_amount) AS total_amount
FROM orders
GROUP BY TO_CHAR(order_date, 'YYYY-MM');
```

在上述示例中，第一个查询根据customer_id对订单进行分组，并使用SUM函数计算每个顾客的订单总金额。第二个查询根据order_date的年份和月份（使用TO_CHAR函数）对订单进行分组，并使用SUM函数计算每个月的订单总金额。

在使用GROUP BY语句时，SELECT子句中的列必须要么是GROUP BY子句中的列，要么是聚合函数的结果列，与其他主流数据库类似。请注意，不同的数据库管理系统可能有一些语法上的细微差别，因此在编写查询语句时应参考相应数据库的官方文档或查询语法参考。

### dm
在DM（达梦数据库）中，GROUP BY语句用于对查询结果进行分组，以实现数据的分组和聚合操作，与其他主流数据库的GROUP BY语句用法类似。

语法：

```sql
SELECT column1, column2, ..., aggregate_function(column_name)
FROM table_name
GROUP BY column1, column2, ...;
```

其中，column1、column2等是您希望按其进行分组的列，aggregate_function是聚合函数，column_name是要进行聚合操作的列名。

示例：

假设有一个名为"orders"的表，其中包含以下列：order_id、customer_id、order_date和order_amount。

1. 计算每个顾客的订单总金额：

```xml
    <select id="getList" resultType="kl.kcsp.modules.monitor.entity.MonitorMetricsCPU" databaseId="dm">
        select
        <if test="unit != null and 'HOUR' == unit.name()">
            create_time as createTime,monitor_value as monitorValue,monitor_id as monitorId
        </if>
        <if test="unit != null and 'TODAY' == unit.name() or 'YESTERDAY' == unit.name()">
            avg(monitor_value) as monitorValue,
            to_date(to_char(year(create_time) || '-' || month(create_time) || '-' || day(create_time) || ' ' || hour(create_time) || ':00:00')) as createTime
        </if>
        <if test="unit != null and 'WEEK' == unit.name()">
            avg(monitor_value) as monitorValue, to_date(create_time, 'YYYY-MM-DD') as createTime
        </if>
        from monitor_metrics_cpu
        <where>
            monitor_id = #{monitorId}
            <if test="firstNode != null and firstNode != ''">
                and first_node = #{firstNode}
            </if>
            <if test="secondNode != null and secondNode != '' and secondNode !='全部'">
                and second_node = #{secondNode}
            </if>
            <if test="startTime != null">
                and create_time >= #{startTime}
            </if>
            <if test="endTime != null">
                and #{endTime} >= create_time
            </if>
            <if test="unit != null and 'TODAY' == unit.name() or 'YESTERDAY' == unit.name()">
                group by to_date(to_char(year(create_time) || '-' || month(create_time) || '-' || day(create_time) || ' ' || hour(create_time) || ':00:00'))
            </if>
            <if test="unit != null and 'WEEK' == unit.name()">
                group by to_date(create_time, 'YYYY-MM-DD')
            </if>
        </where>
    </select>

```


## vastbase
在DM（达梦数据库）中，GROUP BY语句用于对查询结果进行分组，以实现数据的分组和聚合操作，与其他主流数据库的GROUP BY语句用法类似。

语法：

```sql
SELECT column1, column2, ..., aggregate_function(column_name)
FROM table_name
GROUP BY column1, column2, ...;
```

其中，column1、column2等是您希望按其进行分组的列，aggregate_function是聚合函数，column_name是要进行聚合操作的列名。

示例：

假设有一个名为"orders"的表，其中包含以下列：order_id、customer_id、order_date和order_amount。

1. 查询报表

```sql
<select id="queryYWHourMonitorStatis" parameterType="hashmap" resultMap="ClusterMonitorStatisVo" databaseId="kingbaseES">
        select to_char(create_time,'yyyy-mm-dd hh24') as createTime,cluster_cpu as  clusterCpu,cluster_memory as clusterMemory,cluster_disk as clusterDisk,networ_in_flow
        as networInFlow, networ_out_flow as networOutFlow,host_id as hostId,max(net_unit) as unit,net_unit as netUnit
        from host_monitoring   where  1 = 1 and host_type = '1'
        <if test="fromDate != null and fromDate!='' ">
            and to_char(create_time,'yyyy-mm-dd hh24') >=  #{fromDate}
        </if>

        <if test="toDate != null and toDate!='' ">
            and  #{toDate} >= to_char(create_time,'yyyy-mm-dd hh24')
        </if>
        group by createTime, clusterCpu, clusterMemory, clusterDisk,networInFlow, networOutFlow, hostId ,netUnit order by min(create_time) asc
    </select>
```

在使用GROUP BY语句时，只能group by alias