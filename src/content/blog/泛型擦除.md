---
author: cobo
pubDatetime: 2023-01-30T15:57:52.737Z
title: 泛型擦除
featured: false
draft: false
tags:
 - robot
description: this is auto generate
---
#java
# 泛型擦除

泛型类型擦除到底都擦除了哪些信息，是全部擦除吗？
其实java虚拟机规范中为了响应在泛型类中如何获取传入的参数化类型等问题，引入了signature，LocalVariableTypeTable等新的属性来记录泛型信息，所以所谓的泛型类型擦除，仅仅是对方法的code属性中的字节码进行擦除，而元数据中还是保留了泛型信息的，这些信息被保存在class字节码的常量池中，使用了泛型的代码调用处会生成一个signature签名字段，signature指明了这个常量在常量池的地址，这样我们就就可以获取泛型的类型信息了


java泛型是伪泛型，java在编译期所有的泛型信息都会被擦掉。正确理解泛型概念的首要前提是理解类型擦除。例如**List<String>**和**List<Integer>**在编译后都变成**List**。

```java
         ArrayList<String> arrayList1=new ArrayList<String>();
		arrayList1.add("abc");
		ArrayList<Integer> arrayList2=new ArrayList<Integer>();
		arrayList2.add(123);
		System.out.println(arrayList1.getClass()==arrayList2.getClass());
```

## 泛型擦除与多态的冲突和解决方法
泛型重载变重写？
```java
public class Pair<T> {
	private T value;
	public T getValue() {
		return value;
	}
	public void setValue(T value) {
		this.value = value;
	}
}

public class DateInter extends Pair<Date> {
	@Override
	public void setValue(Date value) {
		super.setValue(value);
	}
	@Override
	public Date getValue() {
		return super.getValue();
	}
}
```
在这个子类中，我们设定父类的泛型类型为Pair，在子类中，我们覆盖了父类的两个方法，我们的原意是这样的：
将父类的泛型类型限定为Date，那么父类里面的两个方法的参数都为Date类型
```java
    public Date getValue() {
		return value;
	}
	public void setValue(Date value) {
		this.value = value;
	}
```
实际上，类型擦除后，父类的的泛型类型全部变为了原始类型Object，而子类的类型是Date，参数类型不一样，这如果实在普通的继承关系中，根本就不会是重写，而是重载。

本意是将父类中的泛型转换为Date类型，子类重写参数类型为Date的两个方法

实际上，虚拟机并不能将泛型类型变为Date，只能将类型擦除掉，变为原始类型Object。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。JVM知道你的本意吗？知道！！！可是它能直接实现吗，不能！！！

如果真的不能的话，那我们怎么去重写我们想要的Date类型参数的方法,JVM采用了一个特殊的方法，来完成这项功能，那就是**桥方法**。

**JVM桥方法**
使用`bytecode viewer`插件反编译`DateInteger`类。
```java
public class com/qhong/basic/genericity/DateInter extends com/qhong/basic/genericity/Pair {

  // compiled from: DateInter.java

  // access flags 0x1
  public <init>()V
   L0
    LINENUMBER 13 L0
    ALOAD 0
    INVOKESPECIAL com/qhong/basic/genericity/Pair.<init> ()V
    RETURN
   L1
    LOCALVARIABLE this Lcom/qhong/basic/genericity/DateInter; L0 L1 0
    MAXSTACK = 1
    MAXLOCALS = 1

  // access flags 0x1
  public setValue(Ljava/util/Date;)V
   L0
    LINENUMBER 16 L0
    ALOAD 0
    ALOAD 1
    INVOKESPECIAL com/qhong/basic/genericity/Pair.setValue (Ljava/lang/Object;)V
   L1
    LINENUMBER 17 L1
    RETURN
   L2
    LOCALVARIABLE this Lcom/qhong/basic/genericity/DateInter; L0 L2 0
    LOCALVARIABLE value Ljava/util/Date; L0 L2 1
    MAXSTACK = 2
    MAXLOCALS = 2

  // access flags 0x1
  public getValue()Ljava/util/Date;
   L0
    LINENUMBER 20 L0
    ALOAD 0
    INVOKESPECIAL com/qhong/basic/genericity/Pair.getValue ()Ljava/lang/Object;
    CHECKCAST java/util/Date
    ARETURN
   L1
    LOCALVARIABLE this Lcom/qhong/basic/genericity/DateInter; L0 L1 0
    MAXSTACK = 1
    MAXLOCALS = 1

  // access flags 0x1041
  public synthetic bridge setValue(Ljava/lang/Object;)V
   L0
    LINENUMBER 13 L0
    ALOAD 0
    ALOAD 1
    CHECKCAST java/util/Date
    INVOKEVIRTUAL com/qhong/basic/genericity/DateInter.setValue (Ljava/util/Date;)V
    RETURN
   L1
    LOCALVARIABLE this Lcom/qhong/basic/genericity/DateInter; L0 L1 0
    MAXSTACK = 2
    MAXLOCALS = 2

  // access flags 0x1041
  public synthetic bridge getValue()Ljava/lang/Object;
   L0
    LINENUMBER 13 L0
    ALOAD 0
    INVOKEVIRTUAL com/qhong/basic/genericity/DateInter.getValue ()Ljava/util/Date;
    ARETURN
   L1
    LOCALVARIABLE this Lcom/qhong/basic/genericity/DateInter; L0 L1 0
    MAXSTACK = 1
    MAXLOCALS = 1
}
```
我们本意重写setValue和getValue方法的子类，竟然有4个方法，其实不用惊奇，最后的两个方法，就是编译器自己生成的桥方法。可以看到桥方法的参数类型都是Object，也就是说，子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法。而打在我们自己定义的setvalue和getValue方法上面的@Oveerride只不过是假象。而桥方法的内部实现，就只是去调用我们自己重写的那两个方法。
所以，虚拟机巧妙的使用了巧方法，来解决了类型擦除和多态的冲突。
虚拟机兼容方法签名相同
子类中的桥方法 Object getValue()和Date getValue()是同时存在的，可是如果是常规的两个方法，他们的方法签名是一样的，也就是说虚拟机根本不能分别这两个方法。如果是我们自己编写Java代码，这样的代码是无法通过编译器的检查的，但是虚拟机却是允许这样做的，因为**虚拟机通过参数类型和返回类型**来确定一个方法，所以编译器为了实现泛型的多态允许自己做这个看起来“不合法”的事情，然后交给虚拟器去区别

<T> VS <?>

不同点：

- <T> 用于 泛型的定义，例如 class MyGeneric<T> {...}
- <?> 用于 泛型的声明，即泛型的使用，例如 MyGeneric<?> g = new MyGeneric<>();

相同点
都可以指定上界和下界，例如：
```java
class MyGeneric<T extends Collection> {...}
class MyGeneric<T super List> {...}

MyGeneric<? extends Collection> g = new MyGeneric<>();
MyGeneric<? super List> g = new MyGeneric<>();
```
静态方法，静态类中的泛型
泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数
```java
public class Test2<T> {  
        public static T one;   //编译错误  
        public static  T show(T one){ //编译错误  
            return null;  
        }  
} 
```
因为泛型类中的泛型参数的实例化是在定义对象的时候指定的，而静态变量和静态方法不需要使用对象来调用。对象都没有创建，如何确定这个泛型参数是何种类型，所以当然是错误的

静态方法自己定义的泛型
```java
public class Test2<T> {    
        public static <T >T show(T one){//这是正确的  
            return null;  
        }  
} 
```
