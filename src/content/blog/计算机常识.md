---
author: cobo
pubDatetime: 2023-01-30T15:57:52.737Z
title: 计算机常识
featured: false
draft: false
tags:
 - robot
description: this is auto generate
---
# 计算机常识

## 代理

### 正向代理

正向代理类是一个条班级，代理访问外部资源

![img](305504-20161112124853014-1532060796.png)

正向代理 是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。

#### 用途

- 访问原来无法访问的资源如`google`
- 可以做缓存，加速访问资源
- 对客户端访问授权，上网进行认证
- 代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息

如`ccproxy`,`ccproxy`可以完成两项大功能，代理共享上网和客户端代理权限管理

#### golang实现简单的正向代理

```golang

import (
	"fmt"
	"io/ioutil"
	"net"
	"net/http"
	"strings"
)

//正想代理

type Pxy struct {
}

func (p *Pxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
	fmt.Printf("Received request %s %s %s\n", req.Method, req.Host, req.RemoteAddr)
	transport := http.DefaultTransport
	outReq := new(http.Request)
	*outReq = *req
	if clientIP, _, err := net.SplitHostPort(req.RemoteAddr); err == nil {
		if prior, ok := outReq.Header["X-Forwarded-For"]; ok {
			clientIP = strings.Join(prior, ", ") + ", " + clientIP
		}
		outReq.Header.Set("X-Forwarded-For", clientIP)
	}
	res, err := transport.RoundTrip(outReq)
	if err != nil {
		rw.WriteHeader(http.StatusBadGateway)
		return
	}
	for key, value := range res.Header {
		for _, v := range value {
			rw.Header().Add(key, v)
		}
	}
	rw.WriteHeader(res.StatusCode)
	s, _ := ioutil.ReadAll(res.Body)
	if strings.Contains(req.RequestURI, "html") {
		fmt.Println(req.RequestURI)
	}

	//if req.RequestURI {
	//
	//}
	//fmt.Println(string(s))
	//io.Copy(rw, res.Body)
	//x:=[]byte{'1', '2','3'}
	rw.Write(s)
	res.Body.Close()
}

func main() {
	fmt.Printf("proxy on :8080")
	http.Handle("/", &Pxy{})
	http.ListenAndServe("0.0.0.0:8080", nil)
}
```



### 反向代理

初次接触方向代理的感觉是，客户端是无感知代理的存在的，反向代理对外都是透明的，访问者者并不知道自己访问的是一个代理。因为客户端不需要任何配置就可以访问。

　　反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。

反向代理的作用：

- 保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击

大型网站，通常将反向代理作为公网访问地址，Web服务器是内网。

![img](305504-20161112124341280-1435223816.png)

- 负载均衡，通过反向代理服务器来优化网站的负载

  ![img](305504-20161112124423530-566240666.png)

#### 反向代理例子

```golang
package main

import (
    "log"
    "net/http"
    "net/http/httputil"
)

func main() {
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        director := func(req *http.Request) {
            req = r
            req.URL.Scheme = "http"
            req.URL.Host = r.Host
        }
        proxy := &httputil.ReverseProxy{Director: director}
        proxy.ServeHTTP(w, r)
    })

    log.Fatal(http.ListenAndServe(":8888", nil))
}
```

### 代理访问HTTPS

可以在远程服务器上用http.Get 或client.Do获取http或https网页内容。然后用http.ListenAndServe向本地返回获取到的内容。

```go
package main

import (
    "fmt"
    "io/ioutil"
    "net/http"
)

func main() {
    resp, _ := http.Get("https://www.baidu.com")
    defer resp.Body.Close()
    body, _ := ioutil.ReadAll(resp.Body)
    fmt.Println(string(body))

}
```

或

```go
package main

import (
    "fmt"
    "io/ioutil"
    "net/http"
)

func main() {
    client := &http.Client{}
    req, _ := http.NewRequest("GET", "https://www.baidu.com", nil)
    //req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
    //req.Header.Set("Cookie", "name=any")
    resp, err := client.Do(req)
    defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        // handle error
    }
    fmt.Println(string(body))

}
```

## 机器学习路线

公开课+书+Kaggle 



## PDF

大部分pdf阅读软件，都是基于`poppler`改的

## 程序部署

`Supervisord`可以把程序部署成daemon ，`Supervisord`使用python

## Evosuite配置

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">


	<repositories>

		<repository>
			<id>EvoSuite</id>
			<name>EvoSuite Repository</name>
			<url>http://www.evosuite.org/m2</url>
		</repository>
	</repositories>

	<dependencies>
	
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.12</version>
			<scope>test</scope>
		</dependency>
		<!-- https://mvnrepository.com/artifact/org.evosuite/evosuite-client -->
		<dependency>
			<groupId>org.evosuite</groupId>
			<artifactId>evosuite-client</artifactId>
			<version>1.0.6</version>
		</dependency>

		<dependency>
			<groupId>org.evosuite</groupId>
			<artifactId>evosuite-standalone-runtime</artifactId>
			<version>1.0.6</version>
			<scope>test</scope>
		</dependency>
	</dependencies>
	<build>
		<pluginManagement><!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) -->
			<plugins>
				<plugin>
					<groupId>org.evosuite.plugins</groupId>
					<artifactId>evosuite-maven-plugin</artifactId>
					<version>1.0.6</version>
				</plugin>
			</plugins>
		</pluginManagement>

		<plugins>

		</plugins>
	</build>
</project>

```

```sh
mvn compile -DmemoryInMB=4000 -Dcores=2 -DtargetFolder=src/test/java/evosuite evosuite:generate evosuite:export
```

# 简单网络管理协议(SNMP)

> 用于监控主机状态

**SNMP**是英文"**Simple Network Management Protocol**"的缩写，中文意思是"**简单网络管理协议**"。**SNMP是一种简单网络管理协议，它属于TCP/IP五层协议中的应用层协议，用于网络管理的协议。SNMP主要用于网络设备的管理。由于SNMP协议简单可靠 ，受到了众多厂商的欢迎，成为了目前最为广泛的网管协议。**

　　SNMP协议主要由两大部分构成：SNMP管理站和SNMP代理。SNMP管理站是一个中心节点，负责收集维护各个SNMP元素的信息，并对这些信息进行处理，最后反馈给网络管理员；而SNMP代理是运行在各个被管理的网络节点之上，负责统计该节点的各项信息，并且负责与SNMP管理站交互，接收并执行管理站的命令，上传各种本地的网络信息。

　　SNMP管理站和SNMP代理之间是松散耦合。他们之间的通信是通过UDP协议完成的。一般情况下，SNMP管理站通过UDP协议向SNMP代理发送各种命令，当SNMP代理收到命令后，返回SNMP管理站需要的参数。但是当SNMP代理检测到网络元素异常的时候，也可以主动向SNMP管理站发送消息，通告当前异常状况

SNMP的基本思想：为不同种类的设备、不同厂家生产的设备、不同型号的设备，定义为一个统一的接口和协议，使得管理员可以是使用统一的外观面对这些需要管理的网络设备进行管理。通过网络，管理员可以管理位于不同物理空间的设备，从而大大提高网络管理的效率，简化网络管理员的工作。

## SNMP操作命令

　SNMP协议之所以易于使用，这是因为它对外提供了**三种用于控制MIB对象的基本操作命令**。它们是：**Get、Set 和 Trap**。

1. **Get**：管理站读取代理者处对象的值。它是SNMP协议中使用率最高的一个命令，因为该命令是从网络设备中获得管理信息的基本方式。
2. **Set**：管理站设置代理者处对象的值。它是一个特权命令，因为可以通过它来改动设备的配置或控制设备的运转状态。它可以设置设备的名称，关掉一个端口或清除一个地址解析表中的项等。
3. **Trap**： 代理者主动向管理站通报重要事件。它的功能就是在网络管理系统没有明确要求的前提下，由管理代理通知网络管理系统有一些特别的情况或问题 发生了。如果发生意外情况，客户会向服务器的162端口发送一个消息，告知服务器指定的变量值发生了变化。通常由服务器请求而获得的数据由服务器的161 端口接收。Trap 消息可以用来通知管理站线路的故障、连接的终端和恢复、认证失败等消息。管理站可相应的作出处理。

## 标签
[[小知识]]